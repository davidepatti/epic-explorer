/*==============================================================================*
 *                                                                              *
 * Grid_Loc class is used to represent location of each grid (node) generated by*
 * the recursive binary divsion of the objective space.                         *
 *                                                                              *
 * The location code is acutally a concatenation of binary bit strings, one such*
 * string for each objective. The order of concatenation is from left to right  *
 * with the corresponding objective from 'dimens - 1' to 0.                     *
 *                                                                              *
 * Each string consists of 'cur_depth+1' bit, i.e. 1 bit per division level, in *
 * addition to an extra bit (called PCB: Pareto Comparison Bit) inserted as the *
 * most significant bit for pareto comparsion.                                  *
 *                                                                              * 
 * set(int obj, int level) sets the relative bit corresponding to the given     *
 * objective (not its value, but its index as dimension) and division level.    *
 *                                                                              *
 * compare(const Grid_Loc& other) does pareto comparison with 'other'           *
 *                                                                              *
 *========================================== Feb 25, 2001,  xianming Chen=======*/


#include "Pareto.h"
#include <string>
#include <iostream>

#define maxINTs  10              // the maximum length of location code (in 'int').
#define INTbits  (8*sizeof(int)) // bits per 'int'.

class Grid_Loc : public Pareto {
 public:
  Grid_Loc()                      { memset(code, 0, maxINTs * sizeof(int)); }
  Grid_Loc(int loc)               { memset(code, 0, maxINTs * sizeof(int)); code[0] = loc; }
  Grid_Loc(const Grid_Loc& other) { *this = other; }
  Grid_Loc& operator= (const Grid_Loc& other) {memcpy(code, other.code, maxINTs * sizeof(int));}

  void set(int obj, int level)    { _set(obj*strLenPerObj + strLenPerObj - 1 - level); }

  pRel compare(const Grid_Loc& other) const;
  static bool update(int cur_depth);  // update code representation if necessary.

 private:
  unsigned int code[maxINTs];        // concatenation of binary bit string of each objectives.
                                     // no str will spread from one 'int' to the adjacent 'int'.

  static int sz;                     // Actual size used in the above int arrays.(in 'int').
  static int cur_depth;              // current depth of Pareto tree (binary division).
  static int strLenPerObj;           // bit str length(incl. 1 bit (PCB) reserved for comparison).
  static unsigned int PCC[maxINTs];  // Pareto Comparsion Code: all '0' bits except PCBs.

  static const unsigned int BIT_MASK[INTbits];

  void _set(int pos)   { code[pos/INTbits] |= BIT_MASK[pos%INTbits]; }

#ifdef DEBUG
  char* str(int obj) const; // ret binary bit str of this obj. Caller owns the string.
  bool _setted(int pos) const 
    { return code[pos/INTbits] & BIT_MASK[pos%INTbits] ? true:false; }
 public:
  bool setted(int o, int l) const { return _setted(o*strLenPerObj + strLenPerObj - 1 - l); }
  friend ostream& operator<< (ostream& os, const Grid_Loc& loc);
#endif
};

